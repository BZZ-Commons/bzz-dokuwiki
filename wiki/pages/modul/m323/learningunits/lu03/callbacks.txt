====== LU03f - Callback Funktionen ======

Callback Funktionen sind eine klassische Anwendung von First-Class- und Higher-Order-Functions.


===== Callbacks in der GUI Programmierung =====

Die Entwicklung von grafischen Benutzeroberfl√§chen (GUIs) unterscheidet sich in vielerlei Hinsicht von der Entwicklung von Konsolen- oder Terminalanwendungen. Eine der Hauptunterschiede ist, dass GUI-Anwendungen ereignisgesteuert sind. Das bedeutet, dass statt in einer sequenziellen Reihenfolge von oben nach unten durch den Code zu gehen, die Ausf√ºhrung des Codes oft von Benutzeraktionen wie Mausklicks, Tastatureingaben oder anderen Ereignissen ausgel√∂st wird. Hier kommen ''Callbacks'' ins Spiel.

==== Was sind Callbacks? ====

Ein ''Callback'' ist eine Funktion, die an eine andere Funktion als Argument √ºbergeben wird und zu einem sp√§teren Zeitpunkt in Reaktion auf ein Ereignis ausgef√ºhrt wird. In der GUI-Programmierung werden Callbacks h√§ufig verwendet, um auf Benutzerereignisse zu reagieren.

==== Warum werden Callbacks in der GUI-Programmierung verwendet? ====

  - **Ereignisgesteuerte Natur von GUIs**: Da GUI-Anwendungen darauf warten, dass Benutzerereignisse auftreten, k√∂nnen wir nicht vorhersehen, wann diese Ereignisse eintreten werden. Callbacks bieten eine M√∂glichkeit, spezifische Codebl√∂cke in Reaktion auf bestimmte Ereignisse auszuf√ºhren.
  - **Modularit√§t und Wiederverwendbarkeit**: Durch die Verwendung von Callbacks k√∂nnen Sie spezifische Aktionen isolieren, was den Code sauberer und wiederverwendbarer macht.
  - **Flexibilit√§t**: Callbacks erm√∂glichen es, unterschiedliche Aktionen f√ºr dasselbe Ereignis zu definieren, je nach Kontext oder Zustand der Anwendung.

==== Beispiel ====

In vielen GUI-Frameworks, einschlie√ülich ''tkinter'' in Python, wird ein Button-Widget mit einem Callback verkn√ºpft, um zu definieren, was passieren soll, wenn der Benutzer auf den Button klickt.

<code python>
import tkinter as tk

def on_button_click():
    print('Der Button wurde geklickt!')

root = tk.Tk()
button = tk.Button(root, text='Klicken Sie mich', command=on_button_click)
button.pack()
root.mainloop()
</code>

In diesem Beispiel ist ''on_button_click'' der Callback, der aufgerufen wird, wenn der Benutzer auf den Button klickt.

==== Fazit ====

Callbacks sind ein essenzielles Konzept in der GUI-Programmierung und bieten eine effektive M√∂glichkeit, auf Benutzerereignisse zu reagieren und einen dynamischen, interaktiven Workflow f√ºr Anwendungen zu erstellen.

===== Callbacks in der Asynchronen Programmierung =====

<WRAP center round info 60%>
Wir werden das asynchrone Programmieren nicht vertiefen am BZZ. Dies d√ºrfen Sie dann an der Fachhochschule üòâ
</WRAP>


Asynchrone Programmierung ist ein Ansatz, bei dem Operationen ausgef√ºhrt werden k√∂nnen, ohne den Ablauf des gesamten Programms zu blockieren. Ein h√§ufiges Szenario f√ºr asynchrone Aufrufe sind Netzwerkanfragen, z. B. API-Aufrufe, bei denen nicht vorhersehbar ist, wie lange sie dauern werden.

**Warum Callbacks in asynchronen Aufrufen verwenden?**

  * **Nicht-blockierende Natur:** Bei einem synchronen Aufruf w√ºrde Ihr Code anhalten und warten, bis die Anfrage abgeschlossen ist. Bei einem asynchronen Aufruf kann der Code weiter ausgef√ºhrt werden, ohne auf die Antwort zu warten. Ein Callback erm√∂glicht es, spezifischen Code auszuf√ºhren, sobald die Antwort eintrifft.
  * **Strukturierte Code-Organisation:** Durch die Verwendung von Callbacks k√∂nnen Sie spezifische Aktionen oder Folgeverarbeitungen klar definieren, die nach Abschluss einer Operation ausgef√ºhrt werden sollen.
  * **Fehlerbehandlung:** Callbacks k√∂nnen so gestaltet werden, dass sie sowohl mit normalen Daten als auch mit Fehlern umgehen k√∂nnen. Dies ist besonders n√ºtzlich bei Netzwerkanfragen, bei denen viele Dinge schief gehen k√∂nnen.

**Warum nicht einfach den Code direkt nach dem API-Aufruf ausf√ºhren?**

  * **Unvorhersehbare Antwortzeiten:** Bei synchronem Code, der auf eine Netzwerkanfrage folgt, haben Sie keine Kontrolle dar√ºber, wann die Antwort eintrifft. Ihr gesamtes Programm w√ºrde warten, was zu einer schlechten Benutzererfahrung f√ºhren kann.
  * **Ressourceneffizienz:** Asynchrone Aufrufe erm√∂glichen es, Ressourcen effizienter zu nutzen. W√§hrend Sie auf eine Antwort warten, kann die CPU andere Aufgaben erledigen.
  * **Klarheit und Wartbarkeit:** Durch das Trennen der Logik in verschiedene Funktionen (z. B. eine f√ºr den API-Aufruf und eine andere f√ºr die Verarbeitung der Antwort) wird der Code sauberer und leichter zu warten.


==== Asynchron Programmieren in Python ====

In modernen Anwendungen, insbesondere bei I/O-intensiven Aufgaben wie Netzwerkanfragen, Datenbankzugriffen oder Dateioperationen, ist es oft erforderlich, Operationen asynchron auszuf√ºhren, um die Gesamtleistung der Anwendung zu verbessern. Python bietet mit `async` und `await` ein leistungsf√§higes Werkzeug zur asynchronen Programmierung.

=== Was sind async und await? ===

  * **''async''**: Das Schl√ºsselwort ''async'' definiert eine Funktion als asynchron. Eine solche Funktion gibt ein "Coroutine"-Objekt zur√ºck, das sp√§ter mit ''await'' aufgerufen werden kann.
  * **''await''**: Das Schl√ºsselwort ''await'' wird verwendet, um das Ergebnis einer asynchronen Operation abzurufen. Es kann nur innerhalb einer ''async''-Funktion verwendet werden.


=== Beispiel: Parallele Ausf√ºhrung von Aufgaben ===

Eine der Hauptvorteile von asynchroner Programmierung ist die F√§higkeit, mehrere Aufgaben parallel auszuf√ºhren, insbesondere wenn es um Aufgaben geht, die auf externe Ressourcen warten, wie z.B. Netzwerkanfragen.

<code python>
import asyncio

async def task_1():
    print('Task 1 gestartet')
    await asyncio.sleep(2)
    print('Task 1 abgeschlossen')

async def task_2():
    print('Task 2 gestartet')
    await asyncio.sleep(3)
    print('Task 2 abgeschlossen')

async def main():
    await asyncio.gather(task_1(), task_2())

if __name__ == '__main__':
    asyncio.run(main())
</code>

=== Beispiel: Asynchrone Dateioperation ===

In diesem Beispiel zeigen wir, wie Dateioperationen asynchron ablaufen k√∂nnen. Das Beispiel liest den Inhalt von zwei Dateien asynchron.

<code python>
import aiofiles
import asyncio

async def read_file(file_name):
    async with aiofiles.open(file_name, 'r') as file:
        contents = await file.read()
        print(f'Inhalt von {file_name}: {contents}')

async def main():
    await asyncio.gather(
        read_file('file1.txt'),
        read_file('file2.txt')
    )

if __name__ == '__main__':
    asyncio.run(main())
</code>

=== Beispiel: API-Call mit Zeit√ºberschreitung ===

Ein h√§ufiges Problem bei Netzwerkanfragen ist die Notwendigkeit, eine maximale Wartezeit festzulegen. Dies kann durch die Verwendung von Timeout-Parametern und asynchroner Programmierung gel√∂st werden.

<code python>
import httpx
import asyncio

async def fetch_data():
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get('https://run.mocky.io/v3/685db531-06e7-4d66-bbf6-99de9f2feab3?mocky-delay=3000ms', timeout=5)
            print(response.text)
        except httpx.RequestError as exc:
            print(f'An error occurred while requesting data: {exc}')

async def main():
    await fetch_data()

if __name__ == '__main__':
    asyncio.run(main())
</code>

=== Beispiel: Daten von mehreren APIs gleichzeitig abrufen ===

Hier zeigen wir, wie mehrere API-Aufrufe parallel ablaufen k√∂nnen, um die Effizienz zu verbessern.

<code python>
import httpx
import asyncio


async def fetch_data(url):
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.text


async def main():
    urls = [
        'https://run.mocky.io/v3/685db531-06e7-4d66-bbf6-99de9f2feab3?mocky-delay=3000ms',
        'https://run.mocky.io/v3/685db531-06e7-4d66-bbf6-99de9f2feab3?mocky-delay=2000ms'
    ]
    results = await asyncio.gather(*(fetch_data(url) for url in urls))
    for result in results:
        print(result)


if __name__ == '__main__':
    asyncio.run(main())
</code>

Diese Beispiele zeigen verschiedene n√ºtzliche Anwendungsf√§lle f√ºr die asynchrone Programmierung in Python. Besonders bei I/O-intensiven Aufgaben hilft sie, die Blockierung des Programms zu vermeiden und die Gesamtleistung zu verbessern.
